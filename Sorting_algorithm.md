## 최적의 정렬 알고리즘
- 배열의 정렬상태에 따라서 틀리다.
- 어느정도 정렬되어 있다면 Quick Sort가 Insertion Sort보다 느리다.

## 선택정렬(Selection Sort)
가장 크기가 작은 값 ( 또는 정렬의 우선 순위가 가장 큰 값 ) 을 선택해서 가장 왼쪽으로 이동시키고,
원래 그 자리에 있던 데이터는 빈 자리에 가져다 놓는다.

### 시간복잡도
- O(n^2)

### 장점
- 내림 차순으로 정렬되어 있는 자료를 오름 차순으로 재정렬할 때 최적(역순정렬)

### 단점
- 부분적으로 정렬되어 있는 배열을 정렬할때는 최악의 속도

## 삽입정렬(Insertion Sort)

### 시간복잡도
- O(n^2)

### 장점
- `필요한 경우에만 배열을 정렬한다는 점`
- 만일 배열이 정렬되어 있으면 레코드들을 전혀 이동할 필요가 없다. 따라서 삽입 정렬은 대부분의 데이터가 이미 정렬되어 있는 경우에 많이 사용된다. 또한 삽입 정렬은 데이터의 수가 매우 적을 경우 알고리즘 자체가 매우 간단하므로 보다 유리할 수 있다. 


### 단점
- `데이터의 양이 많고 레코드가 클 경우에 적합하지 않다.`
- 필연적으로 많은 레코드들의 이동을 포함 배열로 이루어진 리스트들의 중간에 새로운 레코드를 삽입하려면 삽입된 위치의 오른쪽에 있는 레코드들은 한 칸씩 오른쪽으로 밀려야 한다.
결과적으로 삽입 정렬은 데이터의 양이 많고 레코드가 클 경우에 적합하지 않음을 알 수 있다


## 버블정렬(Bubble Sort)
첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리로 이동하는 모습이 물속에서 물위로 올라오는 물방울 모양과 같다하여 버블정렬
`n개의 원소에 대하여 n개의 메모리를 사용`

### 시간복잡도
- O(n^2)

### 장점
- 거의 없....(구현이 쉽다?)

### 단점
- 다른알고리즘에 비해 너무 느리다.

## 병합정렬(Merge Sort)
데이터가 1개만 남을 때 까지 분할을 한다.
그러고 작은 단위부터 정렬해서 정렬된 단위들을 계속 병합해가면서 정렬하는 방식

### 시간복잡도
- O(nlogn)

### 장점
- O(n log n)인 알고리즘 중에 유일하게 안정성이 있다.
- 순차적 접근의 효율성이 랜덤 접근보다 더 높은 하드디스크 같은 곳에서 유용하다.

### 단점
- 데이터 전체 크기만한 메모리가 더 필요하다.
- 메모리를 아끼려면 차라리 아래에 나오는 힙 정렬


## 퀵정렬(Quick Sort)
적절한 원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬

### 시간복잡도
- O(nlogn)

### 장점
- 평균적인 상황에서 최고의 성능

### 단점
- 최악(어느정도 정렬된)의 경우 O(n^2)

## 시간복잡도 정리
![](http://c2down.cyworld.co.kr/download?fid=6422316c86e2cc27ffb333c4c0f27883&name=%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2%20%BA%B9%C0%E2%B5%B5.jpg)
- Space Complexity = 필요한 메모리
- stability = 정렬되기 이전의 동일한 데이터끼리의 순서를 정렬 후에도 유지하고 있는가?

## Reference
- [Sorting pros and cons](http://www.brucemerry.org.za/manual/algorithms/sorting.html)
- [정렬별 알고리즘 장단점 및 특징](http://tctt.tistory.com/47)
- [정렬알고리즘 종류및 간단한 설명](http://blog.naver.com/PostView.nhn?blogId=tyboss&logNo=70046128991)
- [정렬알고리즘 시간복잡도 정리](http://3dmpengines.tistory.com/433)
- [정렬 알고리즘 간단정리](http://chocorolls.tistory.com/44)
